<h2 id="disclaimer">Disclaimer</h2>
<p>This work was undertaken strictly for educational and research
purposes. It clearly violates Tobii’s terms of service. The Tobii Eye
Tracker 5 is a commercial device with licensing restrictions, and
attempting to circumvent these protections for production use would be
unauthorized. My motivation was purely educational: to understand how
the device operates and to address an apparent incompatibility with
Tobii’s public macOS SDK, which is constrained by a heavy licensing
model. This documentation is provided for learning purposes only as a
reference for my own work. This information should not be used for any
unauthorized purposes.</p>
<h1 id="introduction">Introduction</h1>
<p>In this post, I’ll walk you through my attempt to reverse engineer
the Tobii Eye Tracker 5 protocol. This project taught me that reverse
engineering commercial hardware is as much about understanding what you
can’t access as what you can. Binary analysis with Ghidra revealed the
multi-layered architecture: USB bulk transfers, the Tobii Tracker
Protocol (TTP) for message framing, and the Platform Runtime Protocol
(PRP) for high-level operations. Working with Ghidra MCP connected to
Claude Code allowed me to systematically decompile binaries, trace
function calls through five different components (DLL, Python
extensions, service binaries, and authorized applications), and document
the complete protocol stack. The project deepened my understanding of
USB protocol engineering, where I learned how control transfers
initialize devices and bulk endpoints stream data. Most importantly, I
learned about the limits of reverse engineering: even with the entire
protocol structure mapped out, cryptographic protection effectively
prevents unauthorized access. The encryption is not superficial
obfuscation but integral to the protocol, with license keys stored
encrypted in firmware and payload data requiring those keys for
decryption.</p>
<p>While I successfully identified the communication protocol, message
structures, and data transfer mechanisms, the encrypted payload layer
ultimately proved insurmountable without the vendor’s license keys. The
journey revealed the sophisticated architecture Tobii employs to protect
their commercial devices: a multi-layered system spanning USB hardware,
platform runtime services, and cryptographic licensing.</p>
<p>The Tobii Eye Tracker 5 is a commercial-grade eye tracking device
that provides gaze data for various applications, from gaming to
assistive technology. Unlike Tobii’s research devices, which offer open
SDK access, the Eye Tracker 5 operates under a restrictive licensing
model. The official SDK requires authentication, and the device itself
uses encrypted communication protocols. When I encountered difficulties
using the macOS SDK and noticed that applications like Talon Voice could
access the device, I became curious about the underlying protocol. The
challenge was clear: Could I reverse engineer the communication protocol
to extract raw eye tracking data? The answer, I discovered, is both yes
and no. Yes, I could map out the protocol structure, identify the USB
endpoints, and understand the message format. No, I could not decrypt
the actual gaze data without Tobii’s unique license keys.</p>
<h1 id="the-reverse-engineering-stack">The Reverse Engineering
Stack</h1>
<p>My approach relied on several key tools and techniques that proved
essential for dissecting the Tobii ecosystem:</p>
<ul>
<li><p>I used Ghidra’s Model Context Protocol integration connected to
Claude Code to analyze multiple binaries. This combination allowed me to
decompile functions, search for specific strings and patterns, and
document findings systematically. The MCP integration meant I could ask
targeted questions about function behavior and get analysis of
decompiled code in real-time.</p></li>
<li><p>I analyzed five key binaries, each revealing different layers of
the protocol: <code>tobii_stream_engine.dll</code> (the Windows SDK
library implementing the high-level Stream Engine API for networked
devices), <code>tobii_research_interop.so</code> (a Python C extension
wrapping the tobii-research API, using the Platform Runtime Protocol),
<code>platform_runtime_IS5LPROENTRY_MAC_x64_service</code> (the macOS
Platform Runtime service that bridges PRP to USB), the Talon Voice
binary (an authorized application that successfully communicates with
the Eye Tracker 5), and <code>setup.sh</code> (the macOS service
installer revealing system integration details).</p></li>
<li><p>Using PyUSB and libusb, I could monitor USB traffic, identify
endpoints, and attempt protocol reimplementation. The Tobii Eye Tracker
5 presents itself as a USB device with vendor ID <code>0x2104</code>
(Tobii AB) and product ID <code>0x0313</code> (EyeChip).</p></li>
<li><p>What emerged was a sophisticated four-layer architecture: USB
bulk transfers (raw hardware communication), Tobii Tracker Protocol or
TTP (message framing and transaction management), Platform Runtime
Protocol or PRP (high-level operations, streams, and properties), and
encryption and licensing (the impenetrable barrier).</p></li>
</ul>
<h1 id="dissecting-the-usb-layer">Dissecting the USB Layer</h1>
<p>The journey began with the lowest level: USB communication. By
analyzing the Talon Voice binary with Ghidra, I identified the core USB
functions responsible for device interaction. The binary contained clear
references to libusb functions like <code>libusb_open</code>,
<code>libusb_claim_interface</code>, and
<code>libusb_bulk_transfer</code>. The initial connection sequence
follows a predictable pattern:</p>
<ol type="1">
<li>Scan USB buses for devices matching VID <code>0x2104</code>, PID
<code>0x0313</code></li>
<li>Call <code>libusb_open()</code> to obtain a device handle</li>
<li>Claim interface 0 with <code>libusb_claim_interface()</code></li>
<li>Read string descriptor 3 to get the device serial number (format:
<code>IS5FF-XXXXXXXXXXXX</code>)</li>
<li>Send a control transfer with <code>bmRequestType=0x41</code>,
<code>bRequest=0x41</code>, <code>wValue=0</code>,
<code>wIndex=0</code>, no data payload</li>
</ol>
<p>The USB endpoints were straightforward to identify:</p>
<ul>
<li>Bulk IN <code>0x82</code> receives data from the device: streaming
video and responses</li>
<li>Bulk OUT <code>0x04</code> sends commands to the device</li>
</ul>
<p>Decompiling the <code>_eye_open</code> function in the Talon binary
revealed the exact initialization sequence:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> _eye_open<span class="op">(</span>libusb_device_handle <span class="op">**</span>handle_out<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>serial_out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    libusb_device_handle <span class="op">*</span>dev_handle<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Open device</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> libusb_open<span class="op">(</span>device<span class="op">,</span> <span class="op">&amp;</span>dev_handle<span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>result <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Claim interface 0</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> libusb_claim_interface<span class="op">(</span>dev_handle<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>result <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        libusb_close<span class="op">(</span>dev_handle<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Read serial number (string descriptor 3)</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> libusb_get_string_descriptor_ascii<span class="op">(</span>dev_handle<span class="op">,</span> <span class="dv">3</span><span class="op">,</span> serial_out<span class="op">,</span> <span class="bn">0x100</span><span class="op">);</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>result <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        libusb_release_interface<span class="op">(</span>dev_handle<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        libusb_close<span class="op">(</span>dev_handle<span class="op">);</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initial control transfer</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> libusb_control_transfer<span class="op">(</span>dev_handle<span class="op">,</span> <span class="bn">0x41</span><span class="op">,</span> <span class="bn">0x41</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> NULL<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">5000</span><span class="op">);</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>result <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        libusb_release_interface<span class="op">(</span>dev_handle<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        libusb_close<span class="op">(</span>dev_handle<span class="op">);</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>handle_out <span class="op">=</span> dev_handle<span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The control transfer with request <code>0x41</code> appears to be a
device initialization or “wake-up” command. Without this transfer,
subsequent bulk operations fail. After initialization, the device
streams data continuously on the bulk IN endpoint <code>0x82</code>. I
captured this data and found it consists of raw grayscale video frames
from the device’s infrared eye cameras (128×128 pixel images at
approximately 60-120 FPS, with pixel values ranging from 0 to 255). This
video stream is what the device uses internally to calculate gaze
position, but it arrives unprocessed. The actual gaze coordinates are
computed somewhere else in the pipeline.</p>
<h1 id="the-tobii-tracker-protocol-ttp">The Tobii Tracker Protocol
(TTP)</h1>
<p>The next layer up from raw USB is the Tobii Tracker Protocol (TTP),
which I discovered by analyzing the Platform Runtime service binary. TTP
defines how messages are structured on top of USB bulk transfers. The
message format is remarkably simple:</p>
<pre><code>Message Structure:
Offset | Size | Description
-------|------|------------
0      | 4    | Transaction ID (big-endian uint32)
4      | 4    | Data length (big-endian uint32)
8      | var  | Data payload (TTP serialized)</code></pre>
<p>Every command sent to the device includes a transaction ID for
matching requests with responses. The data payload is serialized using a
custom format I’ll call “Eye Tracker Protocol” (ETP), which encodes
typed fields. The <code>_eye_cmd</code> function in Talon demonstrates
sending a command:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> _eye_cmd<span class="op">(</span>libusb_device_handle <span class="op">*</span>dev<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>cmd_str<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>response_out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> tid <span class="op">=</span> generate_transaction_id<span class="op">();</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> <span class="op">*</span>data_payload<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> data_len<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Format command string into binary (e.g., &quot;[u]&quot; -&gt; binary blob)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    format_command<span class="op">(</span>cmd_str<span class="op">,</span> <span class="op">&amp;</span>data_payload<span class="op">,</span> <span class="op">&amp;</span>data_len<span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build message: tid + len + data</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> message<span class="op">[</span><span class="dv">8</span> <span class="op">+</span> data_len<span class="op">];</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">*(</span><span class="dt">uint32_t</span><span class="op">*)&amp;</span>message<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> htonl<span class="op">(</span>tid<span class="op">);</span>  <span class="co">// Big-endian transaction ID</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">*(</span><span class="dt">uint32_t</span><span class="op">*)&amp;</span>message<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> htonl<span class="op">(</span>data_len<span class="op">);</span>  <span class="co">// Big-endian length</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    memcpy<span class="op">(&amp;</span>message<span class="op">[</span><span class="dv">8</span><span class="op">],</span> data_payload<span class="op">,</span> data_len<span class="op">);</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Send on bulk OUT endpoint 0x4</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> written<span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> libusb_bulk_transfer<span class="op">(</span>dev<span class="op">,</span> <span class="bn">0x04</span><span class="op">,</span> message<span class="op">,</span> <span class="dv">8</span> <span class="op">+</span> data_len<span class="op">,</span> <span class="op">&amp;</span>written<span class="op">,</span> <span class="dv">5000</span><span class="op">);</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>result <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Wait for response on bulk IN endpoint 0x82 with matching tid</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> wait_for_response<span class="op">(</span>dev<span class="op">,</span> tid<span class="op">,</span> response_out<span class="op">);</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The only command I could definitively identify in the binaries was
<code>"[u]"</code>, which appears to be a setup or version query
command. When formatted into binary by the <code>FUN_1003108a4</code>
function, <code>"[u]"</code> becomes:</p>
<pre><code>Hex: 02 00 00 00 04 00 00 00 00</code></pre>
<p>This suggests an ETP structure like:</p>
<pre><code>Byte 0: Type (0x02)
Bytes 1-4: Length (0x00000004)
Bytes 5-8: Value (0x00000000)</code></pre>
<p>The response to <code>"[u]"</code> is a BSON object containing device
version information. BSON (Binary JSON) appears to be Tobii’s choice for
structured response data. The parsing function
<code>FUN_10030be20</code> extracts fields like
<code>{"$data": version_info}</code> from the response.</p>
<h1 id="the-platform-runtime-protocol-prp">The Platform Runtime Protocol
(PRP)</h1>
<p>The highest abstraction layer is the Platform Runtime Protocol, which
the macOS service uses to expose devices to client applications. PRP
runs over Unix domain sockets or TCP connections, providing a
network-transparent interface to eye trackers. By decompiling the
<code>platform_runtime_IS5LPROENTRY_MAC_x64_service</code> binary and
the <code>tobii_research_interop.so</code> library, I mapped out PRP’s
architecture. Client applications connect to the Platform Runtime
service via Unix socket at <code>/tmp/tobii_stream_engine</code>
(inferred from transport creation functions). The service acts as a PRP
server, translating high-level PRP operations into low-level TTP
messages over USB. PRP messages have a consistent header format:</p>
<pre><code>Offset | Size | Description
-------|------|------------
0      | 4    | Magic number: 0x50525054 (&quot;TPRP&quot;)
4      | 4    | Message length (including header)
8      | 4    | XOR checksum: length ^ 0x50525054
12     | 4    | Operation type
16+    | var  | Operation-specific data</code></pre>
<p>The magic number and checksum provide basic message validation. The
checksum is a simple XOR of the length with the magic number (not
cryptographically secure, but sufficient for detecting corruption).</p>
<p>PRP defines 11 operation types:</p>
<ul>
<li>Streaming data like gaze points</li>
<li>Property change notifications</li>
<li>Set device properties</li>
<li>Get device properties</li>
<li>List properties</li>
<li>Send commands (calibration, licensing, etc.)</li>
<li>Multiple streams combined</li>
</ul>
<p>The protocol supports 34 different stream types, ranging from basic
gaze points to advanced wearable data:</p>
<ul>
<li>Basic gaze coordinates</li>
<li>Full 3D gaze with per-eye data</li>
<li>Eye camera images</li>
<li>Diagnostic images</li>
<li>More than 30 other specialized streams</li>
</ul>
<p>Commands control device behavior and calibration:</p>
<ul>
<li>Authenticate with license credentials</li>
<li>Begin calibration procedure</li>
<li>Collect calibration point</li>
<li>Store license for device access</li>
<li>More than 20 other commands</li>
</ul>
<p>The <code>prp_client_create</code> function in the interop library
revealed how clients authenticate:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> prp_client_create<span class="op">(</span>prp_client_t <span class="op">**</span>client_out<span class="op">,</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>config_data<span class="op">,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">unsigned</span> <span class="dt">long</span> config_len<span class="op">,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">const</span> prp_client_config_t <span class="op">*</span>config<span class="op">,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>                      logging_setup log_setup<span class="op">,</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                      prp_accumulator_alloc_t allocator<span class="op">,</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">const</span> prp_type_license_key_t <span class="op">*</span>license_key<span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                      <span class="co">// ... more parameters) {</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize PRP client context</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    prp_client_t <span class="op">*</span>client <span class="op">=</span> allocate_client<span class="op">();</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create transport (Unix socket to runtime service)</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    client<span class="op">-&gt;</span>transport <span class="op">=</span> transport_create_socket_address<span class="op">(</span>visibility_type_2<span class="op">);</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build connect message with authentication</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    prp_message_t <span class="op">*</span>connect_msg <span class="op">=</span> prp_init_connect_message<span class="op">(</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        client_id<span class="op">,</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        application_signature<span class="op">,</span>  <span class="co">// SHA-256 hash from SDK</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        license_features<span class="op">,</span>       <span class="co">// Required features (gaze, calibration, etc.)</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        license_levels<span class="op">,</span>         <span class="co">// License tier</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        license_key             <span class="co">// Encrypted license key</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Send and await response</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> send_and_wait_response<span class="op">(</span>client<span class="op">-&gt;</span>transport<span class="op">,</span> connect_msg<span class="op">);</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>result <span class="op">!=</span> PRP_ERROR_NO_ERROR<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span>  <span class="co">// PLATMOD_ERROR_UNAUTHORIZED if bad license</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>client_out <span class="op">=</span> client<span class="op">;</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> PRP_ERROR_NO_ERROR<span class="op">;</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The critical fields here are <code>application_signature</code> and
<code>license_key</code>. The signature is a cryptographic hash derived
from the SDK that identifies the application. The license key is
device-specific and encrypted. Without valid credentials, the runtime
service rejects the connection with
<code>PLATMOD_ERROR_UNAUTHORIZED</code>.</p>
<h1 id="the-encryption-barrier">The Encryption Barrier</h1>
<p>This is where my reverse engineering hit an insurmountable wall.
While I successfully traced the entire protocol stack from USB bulk
transfers through TTP message framing to PRP high-level operations, the
actual payload data (the gaze coordinates, pupil diameters, timestamps)
is encrypted. The encryption happens at multiple points:</p>
<ol type="1">
<li><p>License keys are stored encrypted in device firmware. The
<code>License Key Store</code> command (11) accepts an encrypted blob
that only Tobii’s servers can generate. These keys are unique per
device, identified by serial number.</p></li>
<li><p>Even after establishing a connection, stream data payloads are
encrypted. The <code>receive_stream_prp</code> function in the interop
library decrypts incoming stream packages using keys derived from the
license. Without the license, the data remains opaque binary.</p></li>
<li><p>The SDK generates application signatures using a private key held
by Tobii. Reverse engineering this signature generation would require
breaking their cryptographic implementation (a non-trivial task and
ethically questionable).</p></li>
</ol>
<p>I attempted several approaches to circumvent the encryption. I wrote
Python code using PyUSB to connect directly to the device at the USB
layer, bypassing the runtime service:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> usb.core</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> struct</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Find Tobii device</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>dev <span class="op">=</span> usb.core.find(idVendor<span class="op">=</span><span class="bn">0x2104</span>, idProduct<span class="op">=</span><span class="bn">0x0313</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>dev.set_configuration()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>usb.util.claim_interface(dev, <span class="dv">0</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Read serial</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>serial <span class="op">=</span> usb.util.get_string(dev, <span class="dv">3</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Serial: </span><span class="sc">{</span>serial<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial control transfer</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>dev.ctrl_transfer(<span class="bn">0x41</span>, <span class="bn">0x41</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="va">None</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Send setup command &quot;[u]&quot;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>tid <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> <span class="st">b&#39;</span><span class="ch">\x02\x00\x00\x00\x04\x00\x00\x00\x00</span><span class="st">&#39;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>message <span class="op">=</span> struct.pack(<span class="st">&quot;&gt;II&quot;</span>, tid, <span class="bu">len</span>(data)) <span class="op">+</span> data</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>dev.write(<span class="bn">0x4</span>, message)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Read response</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>response <span class="op">=</span> dev.read(<span class="bn">0x82</span>, <span class="bn">0x4000</span>, timeout<span class="op">=</span><span class="dv">5000</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Response: </span><span class="sc">{</span>response<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>This code successfully connects and sends the <code>"[u]"</code>
command. The device responds, but the response payload is a BSON object
that, when decoded, contains version information but no gaze data.
Subscribing to gaze streams requires sending additional commands that I
could not fully decode without understanding the encryption scheme. I
decompiled the <code>_usbman_start</code>,
<code>manager_thread_func</code>, and
<code>send_and_retrieve_response</code> functions to understand how the
service translates PRP to USB. The process is clear: PRP stream
subscriptions become TTP messages with specific operation codes (for
example, <code>0x51</code> for calibration start). However, the actual
data encoding uses lookup tables and cryptographic functions that depend
on the loaded license. I attempted to monitor Talon Voice’s USB traffic
to capture a valid authenticated session. While I could see the bulk
transfers, the payloads were encrypted in transit. Talon must have a
valid license key embedded in its binary, but extracting and reusing it
would violate both Tobii’s and Talon’s terms.</p>
<p>The reality is that Tobii’s licensing model is effective. The
encryption is not a superficial obfuscation but an integral part of the
protocol. Breaking it would require:</p>
<ol type="1">
<li>Either extracting a valid license key from an authorized
application’s memory during runtime or by reverse engineering Tobii’s
key generation algorithm.</li>
<li>Understanding how the license key is transformed into session
encryption keys.</li>
<li>Implementing the decryption algorithm to recover gaze data from
stream packages.</li>
</ol>
<p>Each of these steps involves cryptographic operations designed to
resist reverse engineering. Pursuing them further would cross from
educational exploration into unauthorized circumvention of technical
protection measures.</p>
<h1 id="what-i-learned">What I Learned</h1>
<p>Despite not achieving the goal of extracting gaze data, this project
was deeply educational. I gained hands-on experience with several key
concepts:</p>
<ul>
<li><p>Navigating decompiled C code, identifying function relationships,
and reconstructing high-level logic from assembly. The Ghidra MCP
integration with Claude Code accelerated this process significantly,
allowing me to query specific functions and get analysis on
demand.</p></li>
<li><p>Understanding how USB devices present themselves, how endpoints
work, and how bulk transfers enable high-throughput data streams. The
distinction between control transfers (for commands) and bulk transfers
(for data) became clear through practice.</p></li>
<li><p>Seeing how commercial systems layer protocols (USB for transport,
TTP for message framing, PRP for operations, and encryption for
security) provides a model for robust communication
architecture.</p></li>
<li><p>Appreciating how encryption, when properly integrated into a
protocol, can effectively prevent unauthorized access even when the
entire protocol structure is understood.</p></li>
<li><p>Recognizing the line between educational reverse engineering
(understanding how systems work) and unauthorized access (circumventing
protections for production use).</p></li>
</ul>
<p>The Tobii Eye Tracker 5’s architecture is sophisticated and
well-designed. The separation of concerns between the Platform Runtime
service (handling PRP and licensing) and the low-level USB communication
(TTP) allows Tobii to maintain control over commercial devices while
still supporting research devices through open SDKs. The licensing
model, while restrictive, is understandable from a business perspective:
eye tracking data is valuable, and Tobii invests heavily in the
algorithms that produce it. From a technical standpoint, the protocol is
elegant. The use of BSON for structured data, transaction IDs for
asynchronous messaging, and stream subscriptions for real-time data all
represent solid engineering choices. The encryption layer, while
frustrating for my purposes, demonstrates a commitment to protecting
their intellectual property.</p>
<hr />
<p>Reverse engineering the Tobii Eye Tracker 5 was a journey through
multiple layers of abstraction, from raw USB packets to high-level API
calls. While I successfully mapped the protocol structure and identified
communication patterns, the encrypted payload layer proved to be an
insurmountable barrier without Tobii’s license keys. This experience
reinforced an important lesson: modern commercial systems employ
multi-layered security that goes beyond simple obfuscation.
Understanding a protocol’s structure is not the same as being able to
use it without authorization. For anyone interested in eye tracking, the
takeaway is clear: if you need access to commercial Tobii devices, work
within their SDK and licensing model. The restrictions exist for valid
reasons, and attempting to circumvent them is both technically
challenging and ethically questionable. For research and educational
purposes, Tobii offers research-grade devices with open SDKs that
provide full access without these restrictions. The code and
documentation from this project remain as a testament to what’s possible
with reverse engineering tools and persistence, but also as a reminder
of the limits we should respect. The protocol is documented, the
architecture is understood, but the data remains protected.</p>
