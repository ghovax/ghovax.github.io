Desktop mascots have a special place in computing history—small, animated characters living on your screen, offering a bit of company during long coding sessions. The most famous is Neko, the little cat that chases your mouse cursor, originally written for the PC-9801 in 1989. For a recent project, I wanted to bring this concept to modern macOS, creating not just a faithful recreation of Neko but also a second mascot that explores physics-based animation. The result is two open-source Swift applications: xNeko, a modern implementation of the classic behavior with multiple character skins, and xMascot, a swinging pendant simulation that reacts to gravity and momentum. The code for both is available here: [github.com/ghovax/desktop-mascots](https://github.com/ghovax/desktop-mascots-macos).

### Window Management

The biggest trick in a desktop mascot isn't the animation itself; it's the window management. To make a character look like it's living on your wallpaper, you have to strip away everything that makes a window a window. Building desktop overlays on macOS sits in an interesting intersection of technologies. You need the low-level control of AppKit to manage the window's behavior, but you want modern tools for rendering. I configured the window to be borderless, transparent, and floating. The key property here is ignoring mouse events, which allows clicks to pass right through the mascot to the windows behind it, ensuring the mascot acts as a companion rather than an obstruction. Even the rendering engine choice depended on the specific needs of each mascot: for xNeko, I used SwiftUI to handle the simple frame-based animation loop, while for xMascot, I needed the continuous physics of SpriteKit to simulate the pendulum motion with gravity and damping.

### Animation Logic

While they share the same windowing tricks, the two mascots use fundamentally different logical approaches to feel "alive." xNeko's behavior is driven by a finite state machine with about 18 states. It's not generic AI; it's a specific set of rules that evoke personality. Every frame, the app calculates the vector from the cat to the mouse cursor. If the distance is large, it picks a movement state based on the angle. If it catches the mouse, it enters an "idle" sequence—sitting, scratching an ear, yawning, and finally falling asleep. The cat doesn't teleport; it moves a maximum of 13 pixels per frame toward the target. This simple logic of moving toward a target, stopping if close, and cycling animations if idle is all it takes to make the character feel responsive.

xMascot, on the other hand, relies on simulation rather than states. The mascot hangs from a chain modeled by the standard pendulum equation:

$$ \alpha = -\frac{g}{L} \sin(\theta) $$

where angular acceleration depends on gravity and the current angle. I apply a damping factor every frame to simulate air resistance, causing the motion to decay naturally over time. To prevent it from becoming a static image, a background timer occasionally gives the mascot a small "push" or impulse, starting a swing. This makes it feel like the character is fidgeting or playing, reacting to a simulated physical world rather than just following a script. Projects like this might seem trivial compared to "serious" software, but they are fantastic exercises in system interaction. You learn about window hierarchies, the run loop, coordinate systems, and state management in a fun, visual way.
