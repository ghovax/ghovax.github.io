I've been learning PyTorch extensively and believe the best approach is to combine physics with machine learning. My goal in this article is to show how to model a lens while enforcing physical constraints, so it reproduces a custom pattern via caustics—that is, the rays of light passing through the lens and focusing in specific directions. This problem appears simple but conceals considerable mathematical complexity, which I will explain step by step. 

The setup: a lens with a two free-form surfaces, thickness $t_{lens}$, and radius $r_{lens}$ is positioned at distance $d_{back}$ from a screen where the caustics are projected. The reference axis is defined so that the axis through the lens center is positive when moving away from the screen; thus $z = 0$ is the screen and increases toward the back of the lens. A parallel bundle of rays from infinity strikes the lens under geometric optics, so we treat light only by refraction (Snell's law), neglecting diffraction because the aperture is much larger than the wavelength. We seek the mathematical formulation, subject to physical constraints, for the front surface height $h_{front}(x,y)$ that produces the desired screen pattern; the lens is glass with refractive index $n_{lens} \approx 1.49$.

Given this setup, the goal is to ensure the surface distribution of light intensity projected by the lens shape $h_{front}(x, y)$ closely matches a specified target distribution, which is the pattern we intend to recreate. To do this, we must first understand, in practical terms, the formulas and procedures for tracking the positions of light rays as they propagate through the lens and project onto the screen.

First of all, the light rays come from infinity and all parallel, as a bundle, with a direction versor $\hat{d}_{in} = (0, 0, -1)$ directed to the $z = 0$ of the projection surface. Each ray is coming from a specific point along the $x$ and $y$ axes, $x_{in}$ and $y_{in}$, respectively. They intersect the lens surface at a generic position $z_{front}(x, y) = d_{back} + t_{lens}+ h_{front}(x, y)$. This makes the intersection point between the front surface of the lens given in coordinate space by $\vec{P}_{front} = (x_{in}, y_{in}, z_{front}(x, y))$. To apply Snell's law, refracting the ray, we need to find the surface normal $\hat{n}_{lens}$ at that point, technically given by $\hat{n}_{front} = \frac{\nabla F}{\|\nabla F\|}$, where $F(x, y, z) = z −(d_{back} + t_{lens} + h_{front}(x, y))=0$ is the surface function. This means we need to calculate the gradients of the height function. Because we can express the height function in a differentiable form using Zernike polynomials, PyTorch automatic differentiation computes each component of the derivative, making the calculation trivial. Then, the ray passes from the front surface of the lens through the glass: Snell's law says that the direction of propagation of light within the glass lens, $\hat{d}_{lens}$, upon hitting the surface, is related the $\hat{d}_{in}$ by the refractive index of the glass, $\eta = \frac{1}{n_{lens}}$, as $n_{air} = 1$ by definition. Through geometric identities based on the dot product it's possible to derive that $\hat{d}_{lens} = \eta \hat{d}_{in} + \left(\eta \cos{\theta_{in}} - \sqrt{1 - \eta^2 \sin^2{\theta_{in}}}\right) \hat{n}_{front}$, where $\cos{\theta_{in}} = -\hat{d}_{in} \cdot \hat{n}_{front}$. After it's calculation, this needs to be normalized. To find where the ray hits the back surface of the lens, we need to solve the equation $z_{front} + t_{back} (\hat{d}_{lens} \cdot \hat{z}) = z_{back}$ for $t_{back}$, which yields the intersection point $\vec{P}_{back} = \vec{P}_{front} + t_{back} \hat{d}_{lens}$. Lastly, because the ray of light is going to cross the back of the lens, intersecting with the other free-form surface, the ray will be refracted again until it reaches the projection screen.

